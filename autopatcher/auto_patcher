#!/bin/bash

# version: beta v2.4.5, patches 2012.011.02.

# PDroid created by svyat. Official PDroid thread is 
# http://forum.xda-developers.com/showthread.php?t=1357056

# The Auto-Patcher created by pastime1971 and mateorod
# Thread and support for the Auto-Patcher can be found at
# http://forum.xda-developers.com/showthread.php?p=27589651#post27589651

# ChangeLog
# 2012.05.00. (v0.1) 
# ...........
# 2012.05.12. (v0.2) allows user to specify a different version of patches
# 2012.05.13. (v0.3.0) force "patch -N", remove temp upon failure, generate log output
# 2012.05.13. (v0.3.1) revised the generation of updater-script (SGS2)
# 2012.05.15. added AOSP patches
# 2012.05.15. added crespo-aosp patches, added device-specific patching if patch exists
# 2012.05.15. remove restore.zip upon failure
# 2012.05.15. (v0.4.1) added CM7 (GB) patches
# 2012.05.18. (v0.4.2) added checking for tool commands
# 2012.05.21. (v0.4.3) apply device-specific patches only when it is specified
# 2012.05.26. added task title to log
# 2012.05.31. (v0.4.4) CM9 patches updated, crespo-aosp added
# 2012.06.04. (v0.4.5) added checking tools and rom, added aroma installer support, add patch outputs reroute
# 2012.06.15. CM9 patches updated
# 2012.06.16. (v0.4.6) AOKP patches updated, patch versions restructured
# 2012.06.17. (v0.5.0) patcher script reorganized, removed build.prop
# 2012.06.17. (v0.6.0) auto patcher script for pdroid and v6 patches
# 2012.06.19. (v0.6.1) add patches for CM7.2 Final
# 2012.06.20. (v0.6.2) updated CM 7.2 patches
# 2012.06.23. (v0.6.3) fix symlinks
# 2012.06.26. (v0.6.4) added 0618 patches for cm7 nightlies; removed 0619 cm7.2 final
# 2012.06.27. (v0.6.5) added new CM9 patches (20120626)
# 2012.06.27. (v0.6.6) added CM7 nightly patches (20120625) (finally!)
# 2012.07.02. (v0.7.0) Redid AOSP/AOKP; add Windows support (using Cygwin). Thanks kobik77!
# 2012.07.06. (v0.7.1) updated CM9 patches (20120706)
# 2012.07.08. (v0.7.2) updated AOKP (20120707) and CM9 (20120708) pdroid patches
# 2012.07.11. (v1.0.0) reworked script works on Linux, Mac OSX, and Windows (on Cygwin); 
# 		        added new ICS/JellyBean support for the new V6-Supercharger
# 2012.07.18. (v1.0.1) new CM7/CM9 Pdroid patches (20120718)
# 2012.07.23. (v1.0.2) updated CM9 patches (20120723)
# 2012.07.23. (v1.0.3) updated CM9 patches (20120724)
# 2012.08.06. (v1.5.0) updated smali/baksmali binaries to 1.33
# 2012.08.06. 	       Added Pdroid/V6supercharger support for CM10 Jellybean!
# 2012.08.06.	       Improved PDroid stability and efficiency (Thanks CollegeDev)
# 2012.08.06. (v1.6.0) added aokp-jb patches for pdroid/v6supercharger, script update
# 2012.08.17. (v1.9.5) Added support for pdroid_addon, by CollegeDev.
#		       Added insecure boot.img mod
#		       Added support for aosp-jb (This needs testing, and may not be
#		              a wide patch due to large variation between AOSP roms. 
#                      		          -Please report all experiences!
#		       Updated all v6supercharger patches w/new edits to ProcessList
#                      Major script overhaul in preparation for additional mods!
# 2012.08.20. (1.9.6) Conditional support for Official cm10 and aokp-jb builds
# 2012.08.23. (1.9.7) Final/confirmed pdroid support for Official CM10 and AOKP-JB
# 2012.09.04  (1.9.8) Bundled cygwin-compatible tools (original was corrupt).
#						 For Cygwin, replaced h2b function with simple bash math
#						 conversion (req'd for compat w/ Cygwin tools).
# 2012.08.26. (2.0.0) Added .apk patching
#					  Added 3G Dongle support for Nexus 7
#                     TabletUI support for Nexus 7 (maybe more)
#					  Google Voice support for Nexus 7
#						mods are 3gdongle, tabletUI, voice, or nexus7suite (for all)
#					  Added provisional file copy menu to widen patching base
#
# 2012.09.11. (2.0.1) Cygwin support fixes
# 2012.09.11. (2.0.2) Bugfix for 3gdongle (all)
# 2012.09.16. (2.1.0) Significant restructuring of core operations; added edit text file
#		          fix for "method-cap" errors in pdroid.
# 2012.09.20. (2.1.1) Fix for Phone FC's; OSX support finalized; ContentResolver resolved
# 2012.09.28. (2.1.2) Hotfix for failed pdroid patching. Logging improvements.
# 2012.10.07. (2.1.5) Final pdroid support for CM7.2 Official Releases
#			Added aosp-mod patches for pdroid patching of AOSP kangs
#			Switched to Chainfire's (f)aapt for speed/space reasons
# 2012.10.13. (2.1.6) New PDroid patches for aokp-jb and cm10 4.1.2
#		        Revert (f)aapt- temporary due to reported issues
# 2012.10.15. (2.17)  New (again) CM10 pdroid patches.
#                     Move files to be copied into $p/$R/$B
#                       -This required a bunch of file moving-report broken symlinks. 
#                     Some error check on the old RIL delete functions (thanks bundrik)
# 2012.10.16. (2.1.7.5) Fix FC on phone with CM10 pdroid patches
# 2012.10.19. (2.1.9) Testing CM10 support for PDroid Extension by CollegeDev.
# 2012.10.22. (2.2.0) aosp/aokp and cm10 support for pdroid extension by CollegeDev
#                       MAJOR reworking of patches and improved query. only 4 mod types:
#                       cm, aokp, aosp, and pa. See our OP for details.
# 2012.10.26. (2.3.0) Final (LTS) version. Stable for now until upstream breaks any patches
#                      Thanks to KicknGuitar for the OSX testing!
# 2012.11.01. (2.3.1) Fix for pdroid RIL deletion for older roms
#                       Better Build query logic and help messages
# 2012.11.02. (2.3.5) Add Evervolv support for all mods- Thanks to new maintainer poncik!
#                       Fix method cap for pdroid/pd2.0 for AOKP and kangs
# 2012.11.06. (2.4.0) Update pd2.0 patches to latest pd2.0 release- all except Evervolv
#                       add GsmService to smali.txt; improve rom probe
# 2012.11.08. (2.4.2) Add Evervolv support for pd2.0; Device-specific scripts
#                       Will display error if using a mod on an inapplicable rom
# 2012.11.09. (2.4.5) Error catch for random method issues, fix pd2.0 Evervolv and aosp-jb

# SHELL PROGRAMMING NOTES:
# [ -s FILE ] 
# [[ -n STRING ]] or [[ -z STRING ]] 

VERSION="Auto-Patcher v2.4.5"

echo ""
echo "The $VERSION"
echo ""
# by pastime1971 and mateorod
    	

# pass variables to children
set -a

# function for converting hex to binary- for testing
#function h2b { echo "obase=2; ibase=16; $( echo "$*" | sed -e 's/0x//g' -e 's/\([a-z]\)/\u\1/g' )" | bc; }

printusage () {
        # This could REALLY use some better formatting. Even I find it intimidating looking.
	echo "      The $VERSION"
	echo ""
	echo "usage: $0 [ROMNAME].zip [MODS] [ROMTYPE] [PATCHDATE]"
	echo ""
	echo "* [MODS] can be pdroid, pd2.0, v6supercharger, tabletUI, etc..."
        echo "MODS can be combined by separating them with a comma and NO SPACES!!!"
        echo ""
	echo "* [ROMTYPE] can be cm, aokp, aosp or pa                      [recommended]"
	echo "* [PATCHDATE] will select older patch versions, e.g 2012103     [optional]"
        echo ""
        echo " try \"$0 ROM.ZIP -h\" to see what is available"
	echo ""
	exit 
}

debug () {
        # From printerror. For problems decompiling or patching mostly.
	echo "! please refer to $LOG for any debugging"
	echo ""
	echo "! patching failed."
	echo "! it may be possible to patch $ROM using other patch version"
	echo ""
	cleanup
	printusage
}

cleanup () {
        [ -d "$TEMP" ] && \rm -rf "$TEMP"
}
printerror () {
        # General purpose error. Used for errors in main, as opposed to probe or set-up.
        echo ""
	printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	printtask "!!! error: $@"
	printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	echo ""	
	debug
}

smali_error () {
        # Smali binary error. Problem often goes away on second run.
        echo ""
	printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	printtask "!!! error: $@"
	printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        echo ""
        if [[ `grep 'method index is too large' "$LOG"` != "" ]]; then
                printtask "!!! Problem with method cap !!!"
                printtask "... attempting fix ..."
		. patches/common/framework.jar.sh 2>&1 > ${JAR}.log
                printtask "... rebuild framework.jar ..."
                java -Xmx512M -jar smali.jar -a 15 tmp/${FILE}.out/smali -o tmp/${FILE}.out/classes.dex >> "$LOG" 2>> "$LOG"
		[ -f tmp/${FILE}.out/classes.dex ] || printerror "Could not resolve method cap issue- please submit log"
        else
                printtask "!!! This error is generally due to an unknown bug in the smali binary!"
                echo "In our experience, it goes away if you run the patcher a second time."
                echo " Please run the Auto-Patcher with the same command once again."
                echo ""
                echo "If after the third attempt the same thing happens,"
                echo " please upload your logfile to our support thread!"
                echo ""
	        cleanup
                exit
        fi
}


mismatch () {
        # Function that exposes attempts to apply a mod to an upsupported Android version
        echo ""
	printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	printtask "!!! error: $@"
	printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	echo ""
        cleanup
	printusage
}

romerror () {
        # For when an unsupported romtype is manually entered on the command-line
        echo ""
	printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	printtask "!!! error: $@"
	printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	echo ""
        echo "!!!There are only four supported ROMTYPES:"
        echo "1) cm   2) aokp   3) aosp    4) pa"
        echo ""
        echo "Find out which of the above ROMTYPES your rom is based on and try again!"
        echo ""
        echo "**********************************************"
        cleanup
        printusage
}

misspatch () {
        printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        printtask "!! error: $@ "
        printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        echo ""
        printtask "!! The Auto-Patcher could not find its patches and/or tools!"
        echo ""
        echo "* Did you run ./batch.sh first?"
        echo ""
        echo "The patch_patches.tgz and patch_tools.tgz need to be in this directory,"
        echo "  one way or another..."
        echo ""
        cleanup
        printusage
}

misstools () {
        printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"        
        printtask "!! error: $@ "
        printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        printtask "Your set-up is missing a dependency." 
        echo "We require JDK, patch and cpio."
        echo ""
        echo ""
        echo "Each distro is different"
        echo "but you must ensure you have them all installed and try again."
        echo ""
        cleanup
        printusage
}

printtask () {
	echo "" >> "$LOG"
	echo $@ | tee -a "$LOG"
}

copyfailed () {
	echo ""
	printtask "File for which patching failed:"
	printtask "---------------------------------------------"
	echo ""
	printtask "${FAIL##*/}"
	echo ""
	echo "---------------------------------------------"
	echo ""
	echo "We can try to add a premade copy of those files."
	echo "This sometimes works."
	echo ""
	echo "But IT MAY NOT WORK!!!"
	echo ""
	echo ""
	askconsent && return 0 || return 1
}

askconsent () {
	sleep 1
	echo -n "Do you want to proceed ? (YES/no) "
	read PROCEED
	echo "askconsent final = ${PROCEED}: for $FAIL" >> "$LOG"
	case $PROCEED in
		[Yy] | [Yy][Ee][Ss])
                        return 0;       # successful:
                        echo "*** You (or ApG) have elected to use a prepatched copy of $FAIL ***" >> "$LOG"
			;;
		*)
			return 1;	# error
                        echo "*** You have declined to insert $FAIL by not answering 'yes' at the prompt. ***" >> "$LOG"
			;;
	esac
}

replace_updater () {

# Function for devices that use SDcard installs. Also to be tested for CM7
#  since CM7 seems to use an updater-script that wipes EMMC. Testing

UPDIR=META-INF/com/google/android

        \rm $UPDIR/updater-script
        \cp patches/common/$UPDIR/updater-script $UPDIR
        echo "run_program(\"/sbin/busybox\", \"umount\", \"/system\");" >> UPDATE.txt
        cat UPDATE.txt >> $UPDIR/updater-script
        echo ""
        echo "New updater-script being used:" >> "$LOG"
        echo "-----------------------------" >> "$LOG"
        cat $UPDIR/updater-script >> "$LOG"
}

abspath () {
	case `uname -s` in
	CYGWIN*)
		echo $(cygpath -ua "$1")
		;;
	Darwin)
		#[[ $(echo $1 | awk '/^\//') == $1 ]] && echo "$1" || echo "$PWD/$1"
		[[ ${1:0:1} == "/" ]] && echo "$1" || echo "$PWD/$1"
		;;
	Linux)
                echo $(readlink -f "$1")
		;;
	*)
		if [[ ${1:0:1} == "/" ]]; then
			echo "$1"
		elif [[ ${1:0:2} == "./" ]]; then
			echo "$PWD/${1:2}"
		else
			echo "$PWD/$1"
		fi
		;;
	esac
}

mods_info () {
        case $PID in
        voice)
                FLOOR=4.0.0
                ;;
        v6supercharger)
                FLOOR=4.0.0
                ;;
        pdroid)
                FLOOR=2.3.7
                ;;
        pd2.0)
                FLOOR=4.1.2
                ;;
        external_internal)
                FLOOR=2.3.3
                ;;
        insecure)
                FLOOR=2.3.3
                ;;
        secure)
                FLOOR=2.3.3
                ;;
        3gdongle)
                FLOOR=4.1.0
                ;;
        tabletUI)
                FLOOR=4.1.0
                ;;
        esac
   # strip decimals from android version (i.e. 2.3.7 becomes 237)
                NVID=${VID//[.]/}
                COMPAT=${FLOOR//[.]/}
}

compat_check () {
        for P in ${PID[@]}; do
                mods_info
                if [[ "$NVID" -lt "$COMPAT" ]]; then
                        mismatch "Your rom is too old! The minimum for $P is Android $FLOOR!"
                fi
        done
}
extpath () {
	case `uname -s` in
	CYGWIN*)
		echo $(cygpath -da "$1")
		;;
	*)
		echo $(abspath "$1")
		;;
	esac
}

#contains () { for e in "${@:2}"; do [[ "$e" = "$1" ]] && return 0; done; return 1; }

parse () { echo "${1%%_*}"; }

getbuildprop () {
if [ -f system/build.prop ]; then
	result=(`grep $1 system/build.prop | tr -d '\r' | tr '=' ' '`)
	echo "${result[1]}"
else
	echo ""
fi
}


aosp_mod_check() {
        jar -xvf "$ROMX" system/framework/framework2.jar >> $LOG
                if [ -s system/framework/framework2.jar ]; then
                        ever_check
                else
                        AOSP=aosp-jb
                fi
                echo $AOSP
}

ever_check() {
        MID=$(getbuildprop ro.build.romversion)
        if [[ "$MID" == "Evervolv"* ]]; then
                AOSP=aosp-ever 
        else
                MID=$(getbuildprop ro.build.display.id)
                if [[ "$MID" == "ev"* ]]; then
                        AOSP=aosp-ever
                else
                        AOSP=aosp-mod
                fi
        fi
}

pa_check() {
        CMID=$(getbuildprop ro.modversion)
        PAID=$(getbuildprop ro.pa.version)
        MID=$(getbuildprop ro.build.display.id)
	[[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.build.display.id))
	DID=$(getbuildprop ro.product.device)
	[[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)
        if [[ -n $PAID ]]; then
                RID=pa
        else
                case $CMID in
                        [Pp][Aa]*)
                                RID=pa;
                                ;;
                        *)
                                RID=cm;
                                ;;
                esac
        fi
}

proberom () {
	VID=$(getbuildprop ro.build.version.release)

	if [ "${VID%.*}" == "2.3" ]; then
		ANDR=gingerbread
		RID=cm;
	elif [ "${VID%.*}" == "4.0" ]; then
		ANDR=ics
		MID=$(getbuildprop ro.rommanager.developerid)
		[[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.modversion))
		DID=$(getbuildprop ro.product.device)
		[[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)

		case "$MID" in
		pa|cm9|cm|cyanogenmod*)
			RID=cm;
			;;
		aokp|teamkang)
			RID=aokp;
			;;
		*)
			RID=aosp; 
			echo "!!! $MID is not supported yet, trying generic latest !!!"
			;;
		esac
	elif [ "${VID%.*}" == "4.1" ]; then
		ANDR=jellybean
                CMID=$(getbuildprop ro.cm.version)
                if [[ -n $CMID ]]; then
                        pa_check
                else
		MID=$(getbuildprop ro.build.display.id)
		[[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.build.display.id))
		DID=$(getbuildprop ro.product.device)
		[[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)

		        case "$MID" in
		        cm10|cm*|cyanogenmod*)
			        RID=cm;
			        ;;
		        aokp*|teamkang)
			        RID=aokp;
			        ;;
                        pa*)
                                RID=pa;
                                ;;   
                        ev*)
                                RID=aosp-ever;
                                ;;            
                        *)
			        RID=`aosp_mod_check`;
			        ;;
		        esac
                fi
	else
		printerror "unknown ROM version $VID"
	fi
	echo "... result of ROM check: version= $ANDR rom= $RID ..."
}

# NEW # Advanced build date query
# This should set the patch date automatically.

buildquery() {
UTC=$(getbuildprop ro.build.date.utc)
case `uname -s` in
        [Dd]arwin)
                BDID=`date -r $UTC +%Y%m%d`
                echo "#### Darwin Build Query used ####" >> "$LOG"
                ;;
        *)
                BDID=`date -d "1970-01-01 UTC $UTC seconds" +"%Y%m%d"`
                echo "#### Standard Build Query ####" >> "$LOG"
                ;;
esac

if [ $# -gt 3 ]; then
	BID=${4//,/ };
elif 
# Multiple mods all default to latest- this isn't ideal. Best thing is to institute $BID array
# In python, we would use dictionary. Not sure about best for shell. A GUI would fix.
[[ ${#PID[@]} -gt 1 ]]; then
        BID=latest;
else      
   for P in ${PID[@]}; do
                [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
		[ -d patches/$P/$A/$RID ] && R=$RID || R=generic
		[ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest
		PAR=patches/$P/$A/$R
		PARB=patches/$P/$A/$R/$B
        DATES=`ls patches/$P/$A/$R/ | grep '201*'`
        BID=20201231 # Intialize variable - High so as to determine lowest in first loop.

        # find earliest available patch date
             for i in $DATES; do
                  if [[ $i -lt $BID ]]; then
                        BID=$i
                  fi
             done
        # Check if earliest patches are from before build date. Else use earliest
             if [[ $(($BID-$BDID)) -lt 0 ]]; then
        # If older, than find best match
                        for g in $DATES; do
                           if [[ $(($BDID-$g)) -eq 0 ]]; then
                               # if $UTC matches an available patch- use that patch
                               BID=$g
                               break
                           elif [[ $(($BDID-$g)) -gt 0 ]] && [[ $g -gt $BID ]]; then
                                # loop sets the highest $BID w/o going over $UTC
                                BID=$g
                           fi
                       done
             fi
        echo "... $PID patch date has been set to: $BID..."
        B=$BID
   done
fi
}
        
proberil () {
	RIL=$(getbuildprop ro.telephony.ril_class)
	[[ -n $RIL ]] && printtask "... result of ROM check: RIL= $RIL"
}

garbage () {
	unset GARBAGE
	GARBAGE=($(find $@ -name "*.orig")) && rm -rf ${GARBAGE[@]} && echo "GARBAGE= ${GARBAGE[@]}" >> "$LOG"
	GARBAGE=($(find $@ -name "*.rej"))  && rm -rf ${GARBAGE[@]} && echo "GARBAGE= ${GARBAGE[@]}" >> "$LOG"
}

helpcheck () {
        cd patches
        echo ""
        echo "AVAILABLE PATCHES"
        echo ""
        echo "Note: There are ONLY 4 ROMTYPES: [pa, cm, aokp, and aosp]."
        echo "The Auto-Patcher will automatically slot if you need aosp-jb or aosp-mod"
        echo ""
        echo "*******************************************************************"
        echo ""
        echo "Please keep in mind that the Android flavor {ics, jellybean..etc}"
        echo " is there only for your information and is not needed on the command line"
        echo ""
        find -H * -name 2012* | more -d -10
echo ""
echo "*****************************************************************"
echo ""
echo "All listed mods are currently supported. So if you only see older patches,"
echo "that simply means those early patches are still working for current roms."
echo ""
        cleanup
        printusage
}

rominfo () {
echo "# VER= $VERSION" >> "$LOG"
echo "# OS=  $OSTYPE ${BIT}bit" >> "$LOG"
echo "# VID= $VID" >> "$LOG"
echo "# PID= ${PID[@]}" >> "$LOG"
echo "# MID= $MID" >> "$LOG"
echo "# RID= $RID" >> "$LOG"
echo "# ANDR= $ANDR" >> "$LOG"
echo "# BDID= $BDID" >> "$LOG"
echo "# DID= $DID" >> "$LOG"
echo "# BID= $BID" >> "$LOG"

}

[[ $# -lt 1 || $1 == "-h" || -z $1 ]] && printusage

ROOT=$(abspath `dirname "$0"`)
TOOL="$ROOT/patch_tools.tgz"
PTCH="$ROOT/patch_patches.tgz"
ROM=$(abspath "$1")
ROMX=$(extpath "$1")

if [[ $OSTYPE == "cygwin" ]]; then
	EXE=".exe"
	PGFORM="0x"
fi

DATE=`date +%Y%m%d%H%M%S`
TEMP=$(abspath ./tmp$DATE)
LOG=$(abspath ./log$DATE.txt)
#echo $ROOT $TOOL $ROM $TEMP "$LOG"
echo "ROOT= $ROOT" >> "$LOG"
echo "TOOL= $TOOL" >> "$LOG"
echo "ROM=  $ROM" >> "$LOG"
echo "ROMX= $ROMX" >> "$LOG"

\rm -f restore.zip update.zip

CHK=$(getconf LONG_BIT) 
if [[ $CHK = "64" ]]; then
	BIT=64
else [[ $BIT = "32" ]];
	BIT=32
fi


printtask "### verify tools ###"
which patch >> "$LOG" || misstools "Missing \"patch diff command\""
which tar >> "$LOG" || misstools "Missing \"tar archive command\""
which jar >> "$LOG" || misstools "Missing \"jar (JDK)\""
which java >> "$LOG" || misstools "Missing \"java (JRE)\""
which cpio >> "$LOG" || misstools "Missing \"cpio archive command\""
[ -f "$TOOL" ] || misspatch "patch tool is missing"
[ -f "$PTCH" ] || misspatch "patch patches are missing"
printtask "### verify ROM ###"
[ -f "$ROM" ] || printerror "Cannot find $ROM"
echo "### running $0 $@" >> "$LOG"
mkdir "$TEMP"
cd "$TEMP"

PATH="$TEMP:$PATH"
export PATH
echo "PATH= $PATH" >> "$LOG"

printtask "### unzip patch tools ###"
tar xzf "$TOOL" > /dev/null || printerror "failed extracting tools !!!"

# Get OS specific tools
	case `uname -s` in
		CYGWIN*)
			\mv cygwin/aapt.exe .
			\mv cygwin/*.exe boot/
			\rm -rf cygwin # why? If you want to we can keep/add it to mac/linux, though.
			;;
		[Dd]arwin)
			\mv mac/aapt .
			;;
		[Ll]inux)
			\mv linux/aapt .
			;;
		*)
			\mv linux/aapt .
			;;	
	esac
# Ensure aapt permissions - possibly to one day be expanded to all tools in a function.
chmod a+x aapt$EXE
		
printtask "### unzip patch patches ###"
tar xzf "$PTCH" > /dev/null || printerror "failed extracting patches !!!"

# we need build.prop for both RIL probing and ROM probing
jar -xvf "$ROMX" system/build.prop 2>> "$LOG" || printerror "failed extracting build.prop from $ROMX !!!"

# rom + ril type
proberil
printtask "### probe rom type ###"
proberom

# rom type
if [ $# -gt 1 ]; then
        PIT=$2
        if [[ "$PIT" = "-h" ]]; then
              helpcheck
        fi
fi
if [ $# -gt 2 ]; then
	RID=$3        
        case "$RID" in
		cm10|cm*|cyanogenmod*)
			;;
		aokp*|teamkang)
			RID=aokp;
			;;
                pa*)
                        RID=pa;
                        ;;
                aosp-ever)
                        RID=aosp-ever;
                        ;;                
                aosp*)
			RID=`aosp_mod_check`;
			;;
                *)
                        romerror "$RID is not a valid ROMTYPE!!"
                        ;;
		esac
	echo "... Using $RID patches ..."
else
	echo "... Using results of ROM check ..."	
fi

# patch type
if [ $# -gt 1 ]; then
	PIL=${2//,/ }
else
	#PIL=`ls patches/`
	PIL="pdroid v6supercharger"
        echo "No mods selected. Defaulting to the v6 and Pdroid, just because we can."
fi
# a hack to make sure pdroid is the first mod
[[ ${PIL[@]} =~ pdroid ]] && PID=(pdroid)
for P in ${PIL[@]}; do
	[[ ${PID[@]} =~ $P ]] || PID=(${PID[@]} $P)
done

# Check to make sure selected roms are available for the Android version of patched ROM
compat_check

# Build date
if [ $# -gt 3 ]; then
	BID=$4
        # even here, we should try and create a function that matches as close to the above
        # BID as possible. Now, a bad match (user error) defaults to latest
        echo "... $PID patch date set manually to $BID ..."
else
        buildquery
fi

# echo ROM info
rominfo

if [[ ( "$PID" == "-h" || "$RID" == "-h" || "$BID" == "-h" ) ]]; then
        helpcheck
else
	for P in ${PID[@]}; do
		[ -d patches/$P ] || printerror "$P is not available"
                [ -d patches/$P/$ANDR ] && R=$ANDR || A=all
		[ -d patches/$P/$A/$RID ] && R=$RID || R=generic
		[ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest

		unset FILES
                [ -f patches/$P/files.txt ] && FILES=$(cat patches/$P/files.txt)
		[ -f patches/$P/$A/files.txt ] && FILES=$(cat patches/$P/$A/files.txt)
		[ -f patches/$P/$A/$R/files.txt ] && FILES=$(cat patches/$P/$A/$R/files.txt)
                [ -f patches/$P/$A/$R/$B/files.txt ] && FILES=$(cat patches/$P/$A/$R/$B/files.txt)
                for FILE in ${FILES[@]}; do
			case "$FILE" in
			+system/*)
				[[ ${CID[@]} =~ ${FILE:1} ]] && printerror "${FILE:1} is already being copied" || CID=(${CID[@]} ${FILE:1})
				;;
			-system/*)
				[[ ${EID[@]} =~ ${FILE:1} ]] || EID=(${EID[@]} ${FILE:1})
				;;
			system/*.jar)
				[[ ${JID[@]} =~ $FILE ]] || JID=(${JID[@]} $FILE)
                                echo "set_perm(0, 0, 0644, \"/$FILE\");" >> UPDATE.txt
				;;
			system/*.apk)
				[[ ${AID[@]} =~ $FILE ]] || AID=(${AID[@]} $FILE)
                                echo "set_perm(0, 0, 0644, \"/$FILE\");" >> UPDATE.txt
				;;
			*.img)
				[[ ${IID[@]} =~ $FILE ]] || IID=(${IID[@]} $FILE)
				;;
			system/*)
				[[ ${TID[@]} =~ $FILE ]] || TID=(${TID[@]} $FILE)
				;;
			esac
		done
	done
	echo "### DELETE FILES= ${EID[@]}" >> "$LOG"
	echo "### COPY FILES= ${CID[@]}" >> "$LOG"
	echo "### JAR FILES= ${JID[@]}" >> "$LOG"
	echo "### APK FILES= ${AID[@]}" >> "$LOG"
	echo "### IMG FILES= ${IID[@]}" >> "$LOG"
	echo "### TXT FILES= ${TID[@]}" >> "$LOG"

	printtask "### unzip rom ###"
	# extract system files
	jar -xvf "$ROMX" ${JID[@]} ${AID[@]} ${IID[@]} ${TID[@]} 2>> "$LOG" || printerror "failed extracting ${JID[@]} ${AID[@]} ${IID[@]} from $ROMX !!!"
	#\cp -a system/ backup	# only for debugging purpose

	printtask "### create updater script ###"
	jar -xvf "$ROMX" META-INF/com/google/android/updater-script META-INF/com/google/android/update-binary
	jar -xvf "$ROMX" META-INF/com/google/android/update-binary-installer 1> /dev/null 2> /dev/null
	if [ -f META-INF/com/google/android/update-binary-installer ]; then
		printtask "... using Aroma installer ..."
		\mv META-INF/com/google/android/update-binary-installer META-INF/com/google/android/update-binary
	else
		printtask "... using Clockworkmod installer ..."
	fi
	if [ -f META-INF/com/google/android/update-binary ]; then
		#echo "# original updater-script" >> "$LOG"
		#cat META-INF/com/google/android/updater-script >> "$LOG"

		cat META-INF/com/google/android/updater-script | grep ^mount | grep "/system" | head -n 1 > updater-script
		[ -s updater-script ] || echo "run_program(\"/sbin/busybox\", \"mount\", \"/system\");" > updater-script

		for FILE in ${EID[@]}; do
			# restore the original
			jar -xvf "$ROMX" $FILE 2> /dev/null || printtask "!!! warning $FILE cannot be restored !!!"
		done
		for FILE in ${CID[@]}; do
			# replace with the original or delete it
			jar -xvf "$ROMX" $FILE 2> /dev/null || echo "delete(\"/$FILE\");" >> updater-script
		done

		echo "package_extract_dir(\"system\", \"/system\");" >> updater-script
		# add permission management
		cat META-INF/com/google/android/updater-script | grep set_perm | grep "/system" >> updater-script
		# TODO: remove if we don't need it any more
		for P in ${PID[@]}; do
			if [ -s patches/$P/$A/set_perm.txt ]; then
				echo "...setting permissions..."
				cat patches/$P/$A/set_perm.txt >> updater-script
			fi
		done

		cat META-INF/com/google/android/updater-script | grep ^unmount | grep "/system" | head -n 1 >> updater-script

		[[ ${IID[@]} =~ boot.img ]] && cat META-INF/com/google/android/updater-script | grep "boot.img" >> updater-script

		cat updater-script > META-INF/com/google/android/updater-script

		echo "# generated updater-script" >> "$LOG"
		cat updater-script >> "$LOG"
	else
		# this is not enough any more
		jar -xvf update-template.zip META-INF/com/google/android/update-binary META-INF/com/google/android/updater-script
	fi

	printtask "### create restore.zip ###"
	jar -cvf tmp.zip ${JID[@]} ${AID[@]} ${IID[@]} META-INF > /dev/null 2>> "$LOG"
	java -jar signapk.jar updatecert.pem updatekey.pk8 tmp.zip signed.zip 2>> "$LOG"
	\mv signed.zip restore.zip
	\rm -f tmp.zip

	printtask "### decompile system files ###"

	# decompile system files
	for FILE in ${JID[@]}; do
		JAR=${FILE##*/}
		printtask "... decompile $JAR ..."
		java -jar baksmali.jar -b -a 15 -o tmp/${FILE}.out/smali ${FILE} >> "$LOG" 2>> "$LOG"
		if [ $FILE == "system/framework/framework.jar" ]; then
			printtask "... extract preloaded-classes ..."
			jar -xvf ${FILE} preloaded-classes >> "$LOG" 2>> "$LOG"
			\mv preloaded-classes tmp/${FILE}.out/
		fi
	done
	for FILE in ${AID[@]}; do
		APK=${FILE##*/}
		printtask "... decompile $APK ..."
		if [ $FILE == "system/framework/framework-res.apk" ]; then
			printtask "... installing framework files ..."
			java -jar apktool.jar if $FILE
		fi
		java -jar apktool.jar d -f $FILE tmp/$FILE.out
		
	done
	for FILE in ${IID[@]}; do
		printtask "### unpacking $FILE ###"                
		case "$FILE" in
			boot.img)
                                if [ -f boot.img ]; then
				        cd boot
				        ./unpackbootimg$EXE -i ../boot.img >> "$LOG" 2>> "$LOG"
                                        mkdir ramdisk
				        cd ramdisk
				        gzip -dc ../boot.img-ramdisk.gz | cpio -i >> "$LOG" 2>> "$LOG"
				        cd ../../
                                else
                                        printerror "A mod needs to patch boot.img! This rom does not contains boot.img."
                                fi
				;;
			*)
				printerror "cannot process $FILE"
				;;
                esac
	done


	# apply system modification

        for P in ${PID[@]}; do
                [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
		[ -d patches/$P/$A/$RID ] && R=$RID || R=generic
		[ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest
		PAR=patches/$P/$A/$R
		PARB=patches/$P/$A/$R/$B

		unset FILES COPY DELS JARS APKS IMGS TXTS
                [ -f patches/$P/files.txt ] && FILES=$(cat patches/$P/files.txt)
		[ -f patches/$P/$A/files.txt ] && FILES=$(cat patches/$P/$A/files.txt)
		[ -f patches/$P/$A/$R/files.txt ] && FILES=$(cat patches/$P/$A/$R/files.txt)
                [ -f patches/$P/$A/$R/$B/files.txt ] && FILES=$(cat patches/$P/$A/$R/$B/files.txt)
		for FILE in ${FILES[@]}; do
			case $FILE in
			+system/*)
				COPY=(${COPY[@]} ${FILE:1})
				;;
			-system/*)
				DELS=(${DELS[@]} ${FILE:1})
				;;
			system/*.jar)
				JARS=(${JARS[@]} $FILE)
				;;
			system/*.apk)
				APKS=(${APKS[@]} $FILE)
				;;
			*.img)
				IMGS=(${IMGS[@]} $FILE)
				;;
			system/*)
				TXTS=(${TXTS[@]} $FILE)
				;;
			esac
		done

		[[ -n ${COPY[@]} ]] && printtask "### copy patch $P/$A/$R/$B ###"
		for FILE in ${COPY[@]}; do 
			printtask "... copying $FILE ..."
			DEST=${FILE%/*}
			mkdir -p ./$DEST
			if [ -e patches/$P/$A/$R/$B/$FILE ]; then
				[ -e $FILE ] && printtask "... overwriting $FILE from $P ..."
	 			\cp -av patches/$P/$A/$R/$B/$FILE ./$DEST >> "$LOG"
			else
				printerror "$FILE is missing in the patch"
			fi
		done

		# unconditional smali copying
		[ -f patches/$P/smali.txt ] && SMALI=$(cat patches/$P/smali.txt)
                [ -f patches/$P/$A/smali.txt ] && SMALI=$(cat patches/$P/$A/smali.txt)
		[ -f patches/$P/$A/$R/smali.txt ] && SMALI=$(cat patches/$P/$A/$R/smali.txt)
		[ -f patches/$P/$A/$R/$B/smali.txt ] && SMALI=$(cat patches/$P/$A/$R/$B/smali.txt)
		MOVE=${SMALI##*/}
		for SMALI in ${SMALI[@]}; do
			printtask "... overwriting $MOVE ..."
                                if [ -f patches/$P/$A/$R/provisionals/$SMALI ]; then
                                        \cp -av patches/$P/$ANDR/$R/provisionals/$SMALI tmp/$SMALI >> "$LOG"
                                else
				        \cp -av patches/$P/$ANDR/provisionals/$SMALI tmp/$SMALI >> "$LOG"
                                fi
		done


		[[ -n ${DELS[@]} ]] && printtask "### delete patch $P/$A/$R/$B ###"
		for FILE in ${DELS[@]}; do 
			printtask "... deleting $FILE ..."
	 		\rm -rf ./$FILE
		done

		[[ -n ${JARS[@]} ]] && printtask "### jar patch $P/$A/$R/$B ###"
		for FILE in ${JARS[@]}; do
			JAR=${FILE##*/}
			NAME=${JAR%.jar}
			printtask "... apply $NAME.patch ..."
			patch -Nls -p1 -d tmp/${FILE}.out < $PARB/${NAME}.patch 2>&1 > ${JAR}.log
			cat ${JAR}.log | tee -a "$LOG"
			case "$NAME" in
			framework)
				# patch preloaded-classes only if a patch exists
				if [ -f $PARB/preloaded.patch ]; then
					printtask "... apply preloaded.patch ..."
					patch -Nls -p1 -d tmp/${FILE}.out < $PARB/preloaded.patch 2>&1 > preloaded.log
					cat preloaded.log | tee -a "$LOG"
					[[ `grep FAILED preloaded.log` != "" ]] && printerror "failed preloaded.patch"
				fi
				;;
			*)
				echo -n ""	# do nothing else
				;;
			esac
			# substitute failed smali with premade jar
			unset FAILS
			FAILS=(`grep FAILED ${JAR}.log | sed -e 's/.*smali\///' | sed -e 's/\.rej//'`)
			if [[ -n ${FAILS[@]} ]]; then
				printtask "!!! PATCHING FAILED FOR ${FAILS[@]} !!!"
				echo "### replace ${FAILS[@]} ###" > ${JAR}.log
				for FAIL in ${FAILS[@]}; do
					echo "!!! patch error for $FAIL !!!" >> "$LOG"
					#cat tmp/$FILE.out/smali/${FAIL}.rej >> "$LOG"
					[[ ${SID[@]} =~ $FAIL ]] && printerror "$FAIL was already replaced before"
					[ -f patches/$P/$ANDR/provisionals/${FILE}.out/smali/${FAIL} ] || printerror "failed $FAIL in $JAR cannot be remedied"
					copyfailed || printerror "failed $NAME.patch"
					printtask "... replace $FAIL ..."
					\rm -rf tmp/${FILE}.out/smali/${FAIL} tmp/${FILE}.out/smali/${FAIL}.orig tmp/${FILE}.out/smali/${FAIL}.rej
					\cp -av  patches/$P/$ANDR/provisionals/${FILE}.out/smali/${FAIL} tmp/${FILE}.out/smali/${FAIL} >> "$LOG" || echo "FAILED to cp $FAIL" >> ${JAR}.log
					SID=(${SID[@]} $FAIL)
				done
			fi
			[[ `grep FAILED ${JAR}.log` != "" ]] &&  printerror "failed $NAME.patch"
			garbage tmp/${FILE}.out
			if [ -f patches/$P/$A/$R/$B/${JAR}.sh ]; then
				printtask "... apply $JAR.sh ..."
				. patches/$P/$A/$R/$B/${JAR}.sh 2>&1 > ${JAR}.log
				cat ${JAR}.log | tee -a "$LOG"
			fi
		done

		[[ -n ${APKS[@]} ]] && printtask "### apk patch $P/$R/$B ###"
		for FILE in ${APKS[@]}; do
                    APK=${FILE##*/}
                    if [ -d "tmp/${FILE}.out" ] ; then
			printtask "... apply $APK.patch ..."
				patch -Nls -p2 -d tmp/${FILE}.out < $PARB/${APK}.patch 2>&1 >> ${APK}.log 
				cat ${APK}.log | tee -a "$LOG"
			[[ `grep FAILED ${APK}.log` != "" ]] && printerror "failed $APK.patch"
			garbage tmp/${FILE}.out
                    else
                        echo "No $APK in your ROM. Not able to patch this file."
                        echo "## No $APK in ROM ###" >> "$LOG"
                    fi
		done
		[[ -n ${IMGS[@]} ]] && printtask "### img patch $P/$A/$R/$B ###"
		for FILE in ${IMGS[@]}; do
			IMG=${FILE##*/}
			#NAME=${IMG%.img}
			printtask "... applying $IMG.patch ..."
			patch -Nls -p1 -d boot/ramdisk < $PARB/${IMG}.patch >> "$LOG" || printerror "failed patching $FILE"
			# Special Instructions- married to boot.img patching by necessity, not design. When 
			# added to it's own section, it only runs for one mod. WIP.
			#if [ -f patches/$P/$R/special_instructions.sh ]; then
			#	. patches/$P/$R/special_instructions.sh
			#elif [ -f patches/$P/special_instruction.sh ]; then
			#	. patches/$P/special_instructions.sh
			#fi
		done

		[[ -n ${TXTS[@]} ]] && printtask "### text patch $P/$A/$R/$B ###"
		for FILE in ${TXTS[@]}; do
			TXT=${FILE##*/}
			if [[ -f $PARB/${TXT}.patch ]]; then
				printtask "... apply $TXT.patch ..."
				patch -Nls -p2 -d system/ < $PARB/${TXT}.patch 2>&1 > ${TXT}.log 
				#cat ${TXT}.log | tee -a "$LOG"
				[[ `grep FAILED ${TXT}.log` != "" ]] && printerror "failed $TXT.patch"
			fi
			if [[ -f $PAR/${TXT}.awk ]]; then
				printtask "... apply $TXT.awk ..."
				awk -f $PAR/${TXT}.awk $FILE > text || printerror "failed $TXT.awk"
				mv text $FILE
			fi
			if [[ -f $PAR/${TXT}.sed ]]; then
				printtask "... apply $TXT.sed ..."
				sed -f $PAR/${TXT}.sed $FILE > text || printerror "failed $TXT.sed"
				mv text $FILE
			fi
			if [[ -f $PAR/${TXT}.sh ]]; then
				printtask "... apply $TXT.sh ..."
				. $PAR/${TXT}.sh 2>&1 >> ${TXT}.log || printerror "failed $TXT.sh"
			fi
			garbage system/
		done
	done

# Device specific scripts- Placement is up-for-review
        if [ -f patches/devices/$DID/$DID.sh ]; then
				. patches/devices/$DID/$DID.sh
        fi

# Replace updater-script for CM7-- Testing
        if [ "$ANDR" == "gingerbread" ]; then
                replace_updater
        fi

# Rebuilding system files

	[[ -n ${JID[@]} ]] && printtask "### rebuild jar ###"
	for FILE in ${JID[@]}; do
		JAR=${FILE##*/}
		printtask "... rebuild $JAR ..."
		java -Xmx512M -jar smali.jar -a 15 tmp/${FILE}.out/smali -o tmp/${FILE}.out/classes.dex >> "$LOG" 2>> "$LOG"
		[ -f tmp/${FILE}.out/classes.dex ] || smali_error "failed compiling $JAR !!!"
		jar -ufv ${FILE} -C tmp/${FILE}.out/ classes.dex >> "$LOG" 2>> "$LOG"
		if [ $FILE == "system/framework/framework.jar" ]; then
			jar -ufv ${FILE} -C tmp/${FILE}.out/ preloaded-classes >> "$LOG" 2>> "$LOG"
		fi
	done

	[[ -n ${AID[@]} ]] && printtask "### rebuild apk ###"
        for FILE in ${AID[@]}; do
		APK=${FILE##*/}
		printtask "... rebuild $APK ..."
		java -jar apktool.jar b tmp/${FILE}.out >> "$LOG" 2>> "$LOG" || printerror "failed compiling $FILE !!!"
		jar -uvf $FILE -C tmp/${FILE}.out/build/apk/ . > /dev/null 2>> "$LOG"
		#\rm -r tmp/${FILE}.out
	done	

	[[ -n ${IID[@]} ]] && printtask "### rebuild img ###"
	for FILE in ${IID[@]}; do
		printtask "### rebuild $FILE ###"
		case $FILE in
			boot.img)
				# Rebuilding boot.img
				cd boot
				printtask "... rebuilding ramdisk ..."
				./mkbootfs$EXE ./ramdisk | gzip > ramdisk-new.gz

				printtask "... composing boot.img ..."
				BASE=$(cat boot.img-base)
				# convert hex to decimal in cygwin by prefixing "0x" and C-style arithmetic
				PGSIZE=$((${PGFORM}$(cat boot.img-pagesize)))
				CMDLINE=$(cat boot.img-cmdline)
				echo "cmdline = no_console_suspend=1 console=null $CMDLINE" >> "$LOG"
				echo "pagesize = $PGSIZE" >> "$LOG"
				echo "base = $BASE" >> "$LOG"

				printtask "... rebuilding boot.img ..."
				./mkbootimg$EXE --kernel boot.img-zImage --ramdisk ramdisk-new.gz --cmdline "no_console_suspend=1 console=null $CMDLINE" --base "$BASE" --pagesize "$PGSIZE" -o ../boot.img || printerror "failed building boot.img"
				cd ..
				;;
			*)
				printerror "cannot process $FILE"
				;;
		esac
	done

	printtask "### create update.zip ###"
	jar -cfv tmp.zip ${IID[@]} ${JID[@]} ${AID[@]} ${CID[@]} ${TID[@]} META-INF >> "$LOG" 2>> "$LOG"
	java -jar signapk.jar updatecert.pem updatekey.pk8 tmp.zip update.zip 2>> "$LOG"
	#\rm -f tmp.zip

	#echo "# miscellaneous log" >> "$LOG"

	\mv restore.zip update.zip ..
	echo "### finished ###"
	echo "flash update.zip to install the modified"
	echo "flash restore.zip to restore the original"

	# add announcement- optional.
	for P in ${PID[@]}; do
                [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
		[ -d patches/$P/$A/$RID ] && R=$RID || R=generic
                [ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest

                if [ -f patches/$P/$A/$R/$B/README.txt ]; then
			cat patches/$P/$A/$R/$B/README.txt
                elif [ -f patches/$P/$A/$R/README.txt ]; then
			cat patches/$P/$A/$R/README.txt
		elif [ -f patches/$P/$A/README.txt ]; then
			cat patches/$P/$A/README.txt
		fi
	done
fi
cd ..
\rm -rf "$TEMP"
